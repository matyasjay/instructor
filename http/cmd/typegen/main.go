package main

import (
	"bufio"
	"bytes"
	"fmt"
	"http/pkg/model"
	"http/pkg/util"
	"log"
	"os"
	"regexp"
	"strings"

	"github.com/duythinht/dbml-go/parser"
	"github.com/duythinht/dbml-go/scanner"
	"github.com/skia-dev/go2ts"
)

func main() {
	schemaPath := "../database/schema.dbml"
	modelPath := "./pkg/model/database.go"
	declarationPath := "../frontend/src/lib/types/database.d.ts"

	f, _ := os.Open(schemaPath)
	s := scanner.NewScanner(f)
	parser := parser.NewParser(s)
	dbml, err := parser.Parse()
	if err != nil {
		log.Printf("%s\n", err)
		os.Exit(1)
	}

	var outputLines []string
	output := "// DO NOT EDIT. This file is automatically generated.\n\npackage model\n\n"

	table := len(dbml.Tables) - 1
	for table != -1 {
		currentTable := dbml.Tables[table]
		output = output + fmt.Sprintf("type %v struct {\n", currentTable.Name)
		table = table - 1

		column := len(currentTable.Columns) - 1
		for column != -1 {
			currentColumn := currentTable.Columns[column]
			output = output + fmt.Sprintf("\t%v %v\n",
				util.PascalCase(currentColumn.Name),
				util.DbmlToStruct(currentColumn.Type))
			column = column - 1
		}
		output = output + "}\n\n"
	}


	lines := strings.Split(output, "\n")

	for _, line := range lines {
		fields := strings.Fields(line)

		if len(fields) == 2 {
			fieldName := fields[0]
			typeName := fields[1]
			if fieldName == typeName {
				continue
			}
		}
		outputLines = append(outputLines, line)
	}

	output = strings.Join(outputLines, "\n")

	err = os.WriteFile(modelPath, []byte(output), 0644)
	if err != nil {
		log.Fatal(err)
	}

	ts := go2ts.New()
	ts.Add(model.User{})
	ts.Add(model.PostUserInput{})
	ts.Add(model.Template{})
	ts.Add(model.PostTemplateInput{})
	ts.Add(model.PostTemplateInputInput{})
	ts.Add(model.TemplateInput{})
	ts.Add(model.Service{})
	ts.Add(model.PostServiceInput{})

	f, err = os.Create(declarationPath)
	if err != nil {
		log.Fatal(err)
	}

	err = ts.Render(f)
	if err != nil {
		log.Fatal(err)
	}

	if err = f.Close(); err != nil {
		log.Fatal(err)
	}

	content, err := os.ReadFile(declarationPath)
	if err != nil {
		log.Fatal(err)
	}

	modified := strings.ReplaceAll(string(content), "export", "declare")

	err = os.WriteFile(declarationPath, []byte(modified), 0644)
	if err != nil {
		log.Fatal(err)
	}

	content, err = os.ReadFile(declarationPath)
	if err != nil {
		log.Fatal(err)
	}

	exportRe := regexp.MustCompile(`\bexport\b`)
	interfaceRe := regexp.MustCompile(`^declare interface (\w+) \{$`)
	propertyRe := regexp.MustCompile(`^(\s*)([\w_]+)(\??):`)

	scanner := bufio.NewScanner(strings.NewReader(string(content)))

	inBlock := false

	var buffer bytes.Buffer

	for scanner.Scan() {
		line := scanner.Text()
		line = exportRe.ReplaceAllString(line, "declare")

		if matches := interfaceRe.FindStringSubmatch(line); matches != nil {
			name := matches[1]
			line = "declare type " + name + " = {"
			inBlock = true
			buffer.WriteString(line + "\n")
			continue
		}

		if inBlock {
			if strings.TrimSpace(line) == "}" {
				inBlock = false
				buffer.WriteString(line + "\n")
				continue
			}

			if matches := propertyRe.FindStringSubmatch(line); matches != nil {
				indent := matches[1]
				key := matches[2]
				newKey := util.CamelCase(key)

				colonIndex := strings.Index(line, ":")
				if colonIndex != -1 {
					line = indent + newKey + line[colonIndex:]
				}
			}

			buffer.WriteString(line + "\n")
			continue
		}

		buffer.WriteString(line + "\n")
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile(declarationPath, buffer.Bytes(), 0644)
	if err != nil {
		log.Fatal(err)
	}
}
